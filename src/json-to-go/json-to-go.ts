/**
 * JSON-to-Go: Convert JSON to Go struct
 * Based on mholt's json-to-go tool
 */

interface StructInfo {
    name: string;
    definition: string;
}

export function jsonToGo(jsonStr: string, typename?: string, packageName?: string, inline?: boolean): { go: string; error: string | null } {
    try {
        const json = JSON.parse(jsonStr);
        let structName = typename || 'AutoGenerated';
        
        // 验证结构体名称是否合法，如果非法则使用JsonData
        if (!isValidGoIdentifier(structName)) {
            structName = 'JsonData';
        }
        
        const pkg = packageName || 'main';
        
        let result = '';
        if (!inline) {
            result += `package ${pkg}\n\n`;
        }
        
        const structs: StructInfo[] = [];
        const mainStruct = generateStruct(json, structName, structs);
        
        // 检查是否需要导入time包
        const needsTimeImport = checkNeedsTimeImport(json, structs);
        if (!inline && needsTimeImport) {
            result += 'import "time"\n\n';
        }
        
        // Add all generated structs
        structs.forEach(struct => {
            result += struct.definition + '\n\n';
        });
        
        result += mainStruct;
        
        return {
            go: result,
            error: null
        };
    } catch (error: any) {
        return {
            go: '',
            error: error.message
        };
    }
}

function generateStruct(obj: any, structName: string, structs: StructInfo[]): string {
    if (typeof obj !== 'object' || obj === null) {
        return '';
    }
    
    let structDef = `type ${structName} struct {\n`;
    
    for (const [key, value] of Object.entries(obj)) {
        const fieldName = capitalizeFirst(key);
        const goType = getGoType(value, fieldName, structs);
        let jsonTag = `\`json:"${key}"`;
        
        // 为time.Time类型添加时间格式标签
        if (goType === 'time.Time') {
            jsonTag += ` time_format:"2006-01-02T15:04:05Z07:00"`;
        }
        
        jsonTag += '\`';
        structDef += `\t${fieldName} ${goType} ${jsonTag}\n`;
    }
    
    structDef += '}';
    return structDef;
}

function getGoType(value: any, fieldName: string, structs: StructInfo[]): string {
    if (value === null) {
        return 'any';
    }
    
    switch (typeof value) {
        case 'boolean':
            return 'bool';
        case 'number':
            return Number.isInteger(value) ? 'int' : 'float64';
        case 'string':
            // 检测是否为时间格式
            if (isTimeString(value)) {
                return 'time.Time';
            }
            return 'string';
        case 'object':
            if (Array.isArray(value)) {
                if (value.length === 0) {
                    return '[]any';
                }
                const elementType = getGoType(value[0], fieldName.replace(/s$/, ''), structs);
                return `[]${elementType}`;
            } else {
                // Nested object - create a new struct
                const nestedStructName = fieldName;
                const nestedStruct = generateStruct(value, nestedStructName, structs);
                structs.push({ name: nestedStructName, definition: nestedStruct });
                return nestedStructName;
            }
        default:
            return 'any';
    }
}

function capitalizeFirst(str: string): string {
    if (!str) {
        return str;
    }
    
    // Convert various naming conventions to PascalCase (Go struct field naming)
    // Handle snake_case, kebab-case, camelCase, and mixed cases
    
    // First, normalize the string by replacing separators and splitting on word boundaries
    const words = str
        // Replace underscores and hyphens with spaces
        .replace(/[_-]/g, ' ')
        // Insert space before uppercase letters (for camelCase)
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        // Split by spaces and filter out empty strings
        .split(/\s+/)
        .filter(word => word.length > 0);
    
    // Convert each word to proper case (first letter uppercase, rest lowercase)
    return words
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join('');
}

/**
 * 检查是否需要导入time包
 * @param obj JSON对象
 * @param structs 结构体信息数组
 * @returns 是否需要导入time包
 */
function checkNeedsTimeImport(obj: any, structs: StructInfo[]): boolean {
    // 检查主对象
    if (hasTimeFields(obj)) {
        return true;
    }
    
    // 检查所有嵌套结构体
    for (const struct of structs) {
        if (struct.definition.includes('time.Time')) {
            return true;
        }
    }
    
    return false;
}

/**
 * 递归检查对象是否包含时间字段
 * @param obj 要检查的对象
 * @returns 是否包含时间字段
 */
function hasTimeFields(obj: any): boolean {
    if (typeof obj !== 'object' || obj === null) {
        return false;
    }
    
    for (const value of Object.values(obj)) {
        if (typeof value === 'string' && isTimeString(value)) {
            return true;
        }
        if (Array.isArray(value)) {
            for (const item of value) {
                if (hasTimeFields(item)) {
                    return true;
                }
            }
        } else if (typeof value === 'object' && value !== null) {
            if (hasTimeFields(value)) {
                return true;
            }
        }
    }
    
    return false;
}

/**
 * 检测字符串是否为时间格式
 * @param value 要检测的字符串值
 * @returns 是否为时间格式
 */
function isTimeString(value: string): boolean {
    if (!value || typeof value !== 'string') {
        return false;
    }
    
    // 常见的时间格式正则表达式
    const timePatterns = [
        // ISO 8601 格式: 2023-12-25T10:30:00Z, 2023-12-25T10:30:00.123Z
        /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z?$/,
        // RFC 3339 格式: 2023-12-25T10:30:00+08:00
        /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}([+-]\d{2}:\d{2})?$/,
        // 日期格式: 2023-12-25, 2023/12/25
        /^\d{4}[-/]\d{2}[-/]\d{2}$/,
        // 时间格式: 10:30:00, 10:30:00.123
        /^\d{2}:\d{2}:\d{2}(\.\d{3})?$/,
        // Unix 时间戳 (10位或13位数字)
        /^\d{10}$|^\d{13}$/
    ];
    
    // 检查是否匹配任何时间格式
    for (const pattern of timePatterns) {
        if (pattern.test(value)) {
            return true;
        }
    }
    
    // 尝试使用Date构造函数验证
    const date = new Date(value);
    return !isNaN(date.getTime()) && value.length > 8; // 排除过短的字符串
}

/**
 * 验证是否为合法的Go语言标识符
 * @param name 要验证的名称
 * @returns 是否为合法标识符
 */
function isValidGoIdentifier(name: string): boolean {
    if (!name) {
        return false;
    }
    
    // Go标识符必须以字母或下划线开头
    if (!/^[a-zA-Z_]/.test(name)) {
        return false;
    }
    
    // Go标识符只能包含字母、数字和下划线
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name)) {
        return false;
    }
    
    // 检查是否为Go语言保留字
    const goKeywords = [
        'break', 'case', 'chan', 'const', 'continue', 'default', 'defer', 'else',
        'fallthrough', 'for', 'func', 'go', 'goto', 'if', 'import', 'interface',
        'map', 'package', 'range', 'return', 'select', 'struct', 'switch', 'type',
        'var'
    ];
    
    if (goKeywords.includes(name.toLowerCase())) {
        return false;
    }
    
    return true;
}

// Export is handled by the export keyword above