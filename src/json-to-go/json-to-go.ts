/**
 * JSON-to-Go: Convert JSON to Go struct
 * Based on mholt's json-to-go tool
 */

interface StructInfo {
    name: string;
    definition: string;
}

export function jsonToGo(jsonStr: string, typename?: string, packageName?: string, inline?: boolean): { go: string; error: string | null } {
    try {
        const json = JSON.parse(jsonStr);
        const structName = typename || 'AutoGenerated';
        const pkg = packageName || 'main';
        
        let result = '';
        if (!inline) {
            result += `package ${pkg}\n\n`;
        }
        
        const structs: StructInfo[] = [];
        const mainStruct = generateStruct(json, structName, structs);
        
        // Add all generated structs
        structs.forEach(struct => {
            result += struct.definition + '\n\n';
        });
        
        result += mainStruct;
        
        return {
            go: result,
            error: null
        };
    } catch (error: any) {
        return {
            go: '',
            error: error.message
        };
    }
}

function generateStruct(obj: any, structName: string, structs: StructInfo[]): string {
    if (typeof obj !== 'object' || obj === null) {
        return '';
    }
    
    let structDef = `type ${structName} struct {\n`;
    
    for (const [key, value] of Object.entries(obj)) {
        const fieldName = capitalizeFirst(key);
        const goType = getGoType(value, fieldName, structs);
        const jsonTag = `\`json:"${key}"\``;
        structDef += `\t${fieldName} ${goType} ${jsonTag}\n`;
    }
    
    structDef += '}';
    return structDef;
}

function getGoType(value: any, fieldName: string, structs: StructInfo[]): string {
    if (value === null) {
        return 'interface{}';
    }
    
    switch (typeof value) {
        case 'boolean':
            return 'bool';
        case 'number':
            return Number.isInteger(value) ? 'int' : 'float64';
        case 'string':
            return 'string';
        case 'object':
            if (Array.isArray(value)) {
                if (value.length === 0) {
                    return '[]interface{}';
                }
                const elementType = getGoType(value[0], fieldName.replace(/s$/, ''), structs);
                return `[]${elementType}`;
            } else {
                // Nested object - create a new struct
                const nestedStructName = fieldName;
                const nestedStruct = generateStruct(value, nestedStructName, structs);
                structs.push({ name: nestedStructName, definition: nestedStruct });
                return nestedStructName;
            }
        default:
            return 'interface{}';
    }
}

function capitalizeFirst(str: string): string {
    if (!str) return str;
    
    // Convert snake_case or kebab-case to PascalCase
    return str
        .split(/[_-]/) // Split by underscore or hyphen
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join('');
}

// Export is handled by the export keyword above