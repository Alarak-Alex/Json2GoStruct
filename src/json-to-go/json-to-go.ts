/**
 * JSON-to-Go: Convert JSON to Go struct
 * Based on mholt's json-to-go tool
 * Optimized for better performance and type safety
 */

// ==================== 类型定义 ====================

/** Go 基础类型 */
type GoBaseType = 'bool' | 'int' | 'float64' | 'string' | 'time.Time' | 'any';

/** Go 类型（包括复合类型） */
type GoType = GoBaseType | `[]${string}` | string;

/** 结构体信息 */
interface StructInfo {
    name: string;
    definition: string;
    hasTimeFields?: boolean;
}

/** 转换选项 */
interface ConversionOptions {
    typename?: string;
    packageName?: string;
    inline?: boolean;
    omitEmpty?: boolean;
}

/** 转换结果 */
interface ConversionResult {
    go: string;
    error: string | null;
}

/** 字段信息 */
interface FieldInfo {
    name: string;
    goType: GoType;
    jsonKey: string;
    isOptional?: boolean;
}

// ==================== 常量定义 ====================

/** Go 语言保留字 */
const GO_KEYWORDS = new Set([
    'break', 'case', 'chan', 'const', 'continue', 'default', 'defer', 'else',
    'fallthrough', 'for', 'func', 'go', 'goto', 'if', 'import', 'interface',
    'map', 'package', 'range', 'return', 'select', 'struct', 'switch', 'type', 'var'
]);

/** 预编译的时间格式正则表达式 */
const TIME_PATTERNS = [
    // ISO 8601 格式: 2023-12-25T10:30:00Z, 2023-12-25T10:30:00.123Z
    /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z?$/,
    // RFC 3339 格式: 2023-12-25T10:30:00+08:00
    /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}([+-]\d{2}:\d{2})?$/,
    // 日期格式: 2023-12-25, 2023/12/25
    /^\d{4}[-/]\d{2}[-/]\d{2}$/,
    // 时间格式: 10:30:00, 10:30:00.123
    /^\d{2}:\d{2}:\d{2}(\.\d{3})?$/,
    // Unix 时间戳 (10位或13位数字)
    /^\d{10}$|^\d{13}$/
] as const;

/** 预编译的命名转换正则表达式 */
const NAMING_PATTERNS = {
    separators: /[_-]/g,
    camelCase: /([a-z])([A-Z])/g,
    spaces: /\s+/,
    identifier: /^[a-zA-Z_][a-zA-Z0-9_]*$/
} as const;

/** 默认配置 */
const DEFAULT_CONFIG = {
    packageName: 'main',
    structName: 'AutoGenerated',
    fallbackStructName: 'JsonData'
} as const;

// ==================== 主要函数 ====================

/**
 * 将 JSON 字符串转换为 Go 结构体
 * @param jsonStr JSON 字符串
 * @param typename 结构体名称
 * @param packageName 包名
 * @param inline 是否内联模式
 * @returns 转换结果
 */
export function jsonToGo(
    jsonStr: string, 
    typename?: string, 
    packageName?: string, 
    inline?: boolean
): ConversionResult {
    try {
        // 输入验证
        if (!jsonStr?.trim()) {
            return { go: '', error: 'Empty JSON input' };
        }

        const json = JSON.parse(jsonStr);
        const options: ConversionOptions = {
            typename: validateAndFixStructName(typename),
            packageName: packageName || DEFAULT_CONFIG.packageName,
            inline: Boolean(inline)
        };
        
        return convertJsonToGo(json, options);
    } catch (error: any) {
        return {
            go: '',
            error: `JSON parsing error: ${error.message}`
        };
    }
}

/**
 * 核心转换逻辑
 */
function convertJsonToGo(json: any, options: ConversionOptions): ConversionResult {
    const structs: StructInfo[] = [];
    const structCache = new Map<string, string>();
    
    // 生成主结构体
    const mainStruct = generateStruct(json, options.typename!, structs, structCache);
    
    // 检查是否需要导入 time 包
    const needsTimeImport = structs.some(s => s.hasTimeFields) || 
                           mainStruct.includes('time.Time');
    
    // 构建最终结果
    let result = '';
    
    if (!options.inline) {
        result += `package ${options.packageName}\n\n`;
        
        if (needsTimeImport) {
            result += 'import "time"\n\n';
        }
    }
    
    // 添加所有生成的结构体（按依赖顺序）
    structs.forEach(struct => {
        result += struct.definition + '\n\n';
    });
    
    result += mainStruct;
    
    return { go: result, error: null };
}

/**
 * 生成结构体定义
 */
function generateStruct(
    obj: any, 
    structName: string, 
    structs: StructInfo[], 
    cache: Map<string, string>
): string {
    if (typeof obj !== 'object' || obj === null) {
        return '';
    }
    
    // 检查缓存
    const cacheKey = JSON.stringify(obj) + structName;
    if (cache.has(cacheKey)) {
        return cache.get(cacheKey)!;
    }
    
    const fields: FieldInfo[] = [];
    let hasTimeFields = false;
    
    // 分析所有字段
    for (const [key, value] of Object.entries(obj)) {
        const fieldName = capitalizeFirst(key);
        const goType = getGoType(value, fieldName, structs, cache);
        
        fields.push({
            name: fieldName,
            goType,
            jsonKey: key,
            isOptional: value === null || value === undefined
        });
        
        if (goType === 'time.Time') {
            hasTimeFields = true;
        }
    }
    
    // 构建结构体定义
    let structDef = `type ${structName} struct {\n`;
    
    fields.forEach(field => {
        let jsonTag = `\`json:"${field.jsonKey}"`;
        
        // 为 time.Time 类型添加时间格式标签
        if (field.goType === 'time.Time') {
            jsonTag += ` time_format:"2006-01-02T15:04:05Z07:00"`;
        }
        
        // 为可选字段添加 omitempty
        if (field.isOptional) {
            jsonTag += ',omitempty';
        }
        
        jsonTag += '\`';
        structDef += `\t${field.name} ${field.goType} ${jsonTag}\n`;
    });
    
    structDef += '}';
    
    // 缓存结果
    cache.set(cacheKey, structDef);
    
    // 记录结构体信息
    structs.push({ 
        name: structName, 
        definition: structDef, 
        hasTimeFields 
    });
    
    return structDef;
}

/**
 * 获取 Go 类型
 */
function getGoType(
    value: any, 
    fieldName: string, 
    structs: StructInfo[], 
    cache: Map<string, string>
): GoType {
    if (value === null || value === undefined) {
        return '*string'; // 使用指针类型处理可选字段
    }
    
    switch (typeof value) {
        case 'boolean':
            return 'bool';
            
        case 'number':
            return Number.isInteger(value) ? 'int' : 'float64';
            
        case 'string':
            return isTimeString(value) ? 'time.Time' : 'string';
            
        case 'object':
            if (Array.isArray(value)) {
                return getArrayType(value, fieldName, structs, cache);
            } else {
                return getObjectType(value, fieldName, structs, cache);
            }
            
        default:
            return 'any';
    }
}

/**
 * 获取数组类型
 */
function getArrayType(
    array: any[], 
    fieldName: string, 
    structs: StructInfo[], 
    cache: Map<string, string>
): GoType {
    if (array.length === 0) {
        return '[]any';
    }
    
    // 分析数组元素类型
    const elementTypes = new Set<GoType>();
    const sampleSize = Math.min(array.length, 5); // 只检查前5个元素以提高性能
    
    for (let i = 0; i < sampleSize; i++) {
        const elementType = getGoType(
            array[i], 
            fieldName.replace(/s$/, ''), 
            structs, 
            cache
        );
        elementTypes.add(elementType);
    }
    
    // 如果所有元素类型相同，使用该类型
    if (elementTypes.size === 1) {
        return `[]${Array.from(elementTypes)[0]}`;
    }
    
    // 如果类型不一致，使用 any
    return '[]any';
}

/**
 * 获取对象类型
 */
function getObjectType(
    obj: any, 
    fieldName: string, 
    structs: StructInfo[], 
    cache: Map<string, string>
): string {
    const nestedStructName = fieldName;
    generateStruct(obj, nestedStructName, structs, cache);
    return nestedStructName;
}

// ==================== 工具函数 ====================

/**
 * 将字符串转换为 PascalCase（Go 结构体字段命名规范）
 * 优化版本，使用预编译的正则表达式
 */
function capitalizeFirst(str: string): string {
    if (!str) return str;
    
    // 使用预编译的正则表达式进行转换
    const words = str
        .replace(NAMING_PATTERNS.separators, ' ')
        .replace(NAMING_PATTERNS.camelCase, '$1 $2')
        .split(NAMING_PATTERNS.spaces)
        .filter(word => word.length > 0);
    
    return words
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join('');
}

/**
 * 检测字符串是否为时间格式
 * 优化版本，使用预编译的正则表达式
 */
function isTimeString(value: string): boolean {
    if (!value || typeof value !== 'string' || value.length < 8) {
        return false;
    }
    
    // 使用预编译的正则表达式进行快速检测
    for (const pattern of TIME_PATTERNS) {
        if (pattern.test(value)) {
            return true;
        }
    }
    
    // 最后尝试使用 Date 构造函数验证
    try {
        const date = new Date(value);
        return !isNaN(date.getTime());
    } catch {
        return false;
    }
}

/**
 * 验证并修复结构体名称
 */
function validateAndFixStructName(name?: string): string {
    if (!name) {
        return DEFAULT_CONFIG.structName;
    }
    
    if (isValidGoIdentifier(name)) {
        return name;
    }
    
    return DEFAULT_CONFIG.fallbackStructName;
}

/**
 * 验证是否为合法的 Go 语言标识符
 * 优化版本，使用预编译的正则表达式和 Set
 */
function isValidGoIdentifier(name: string): boolean {
    if (!name) return false;
    
    // 使用预编译的正则表达式进行快速检测
    if (!NAMING_PATTERNS.identifier.test(name)) {
        return false;
    }
    
    // 使用 Set 进行快速关键字检查
    return !GO_KEYWORDS.has(name.toLowerCase());
}

// ==================== 导出 ====================

// 保持向后兼容性的导出
export { ConversionResult, ConversionOptions, StructInfo };